---
title: '升级 Prisma 层'
# metaTitle: 'Upgrading the Prisma layer to Prisma 2'
# metaDescription: 'Learn how to upgrade the Prisma layer to Prisma 2 and create your Prisma schema.'
dbSwitcher: ['postgres', 'mysql']
techMetaTitles:
  [
    { name: 'mysql', value: '升级 Prisma 层至 Prisma 2 | MySQL' },
    { name: 'postgres', value: '升级 Prisma 层至 Prisma 2 | PostgreSQL' },
  ]
techMetaDescriptions:
  [
    {
      name: 'mysql',
      value: '学习在 MySQL 中如何升级 Prisma 层至 Prisma 2 并创建 Prisma 模型',
    },
    {
      name: 'postgres',
      value: '学习在 PostgreSQL 中如何升级 Prisma 层至 Prisma 2 并创建 Prisma 模型',
    },
  ]
---

## 概述

本页介绍了升级过程的第一步：将 Prisma 1 配置升级到 Prisma 2。具体而言，您将学习如何：

1. 添加 Prisma 2 CLI 作为开发依赖
1. 创建 Prisma 2 模型
1. 确定连接 URL 并连接到数据库
1. 内省数据库（到目前为止，这是由 Prisma 1 管理的）
1. 使用 [Prisma Upgrade CLI](./how-to-upgrade#prisma-upgrade-cli) 来解决新 Prisma 2 数据模型的[模型不兼容](./schema-incompatibilities-postgres)问题
1. 安装并生成 Prisma Client

完成这些步骤后，您可以继续阅读下一个指南，该指南解释了如何升级应用程序层以使用 Prisma Client 进行数据库查询。

> 注意：在升级过程中，获取数据库的图形视图可能会有帮助。因此，建议使用图形数据库客户端连接到数据库，如 [TablePlus](https://tableplus.com/) 或 [Postico](https://eggerapps.at/postico/)。

## 1. 安装 Prisma 2 CLI

Prisma 2 CLI 作为 [`prisma`](https://www.npmjs.com/package/prisma) NPM 包已可用，通过 `prisma` 命令调用。

请注意，prisma 1 以前的 `prisma` 命令已重命名为 `prisma1`。了解更多请参考[这里](https://www.prisma.io/blog/prisma-2-beta-b7bcl0gd8d8e/#renaming-the-prisma2-cli)。

你可以参考如下内容在你的 Node.js 项目中安装 Prisma 2 CLI （确保在 `package.json` 所在的目录中调用此命令）：

```terminal copy
npm install prisma --save-dev
```

> 注意：对于 Prisma 1，通常建议全局安装 CLI。 我们现在推荐[本地化安装 Prisma CLI](../../../concepts/components/prisma-cli/installation#local-installation-recommended) 以防止版本冲突。

现在，您可以在其命令前加上 `npx` 使用 `prisma` CLI 的本地化安装：

```terminal
npx prisma
```

如果你要[一次性](./how-to-upgrade#upgrade-strategies)升级整个项目, 那么你还可以现在卸载 Prisma 1 CLI（否则，请展开下面）：

```terminal
# remove global installation
npm uninstall -g prisma

# remove local installation
npm uninstall prisma
```

<br />
<details><summary>如果要继续并排使用 Prisma 1 CLI，请展开</summary>

如果要继续使用 Prisma 1 CLI，建议删除它的全局安装，并将 `prisma1` CLI 添加为开发依赖项：

```terminal
# installs v1.34 of the Prisma 1 CLI
npm uninstall -g prisma
npm install prisma1 --save-dev
```

现在可以按如下方式调用它：

```terminal
npx prisma1
```

请注意，如果需要小于 1.34（例如 1.30）的 CLI 版本，可以按如下方式安装：

```terminal
# installs v1.30 of the Prisma 1 CLI
npm uninstall -g prisma@1.30
npm install prisma@1.30 --save-dev
```

现在可以按如下方式调用它：

```terminal
npx prisma
```

</details>

## 2. 创建 Prisma 2 模型

对于本指南，您将首先使用 `Prisma init` 命令创建一个新的 Prisma 模型，然后使用[内省](../../../concepts/components/introspection)。

运行以下命令以创建 Prisma 模型（请注意，如果您已经有一个名为 `Prisma` 的文件夹，则会抛出一个错误`）：

```terminal copy
npx prisma init
```

如果您看到以下错误，则需要重命名当前的 `prisma` 目录：

```no-lines
ERROR  A folder called prisma already exists in your project.
       Please try again in a project that is not yet using Prisma.
```

您可以将当前的 `prisma` 目录重命名为 `prisma1`，以明确此目录包含以前的 Prisma 1 配置：

```terminal copy
mv prisma prisma1
```

现在可运行 `init` 且将成功：

```terminal copy
npx prisma init
```

它应打印以下输出：

```no-lines
✔ Your Prisma schema was created at prisma/schema.prisma.
  You can now open it in your favorite editor.

Next steps:
1. Set the `DATABASE_URL` in the `.env` file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started
2. Set the `provider` of your `datasource` block in `schema.prisma` to match your database: `postgresql`, `mysql` or `sqlite`.
3. Run `prisma db pull` to turn your database schema into a Prisma data model.
4. Run `prisma generate` to install Prisma Client. You can then start querying your database.

More information in our documentation:
https://pris.ly/d/getting-started
```

此命令将创建名为 `prisma` 的文件夹和两个文件：

- `prisma/schema.prisma`: 用以说明[数据源](../../../concepts/components/prisma-schema/data-sources)，[生成器](../../../concepts/components/prisma-schema/generators)和[数据模型](../../../concepts/components/prisma-schema/data-model)的 Prisma 模型文件（注意，数据模型还不存在，它将通过内省生成）。
- `.env`: 用以配置 [连接 URL](../../../reference/database-reference/connection-urls) 的 [dotenv](https://github.com/motdotla/dotenv#readme) 文件。

您的初始 Prisma 模型如下所示：

```prisma file=schema.prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}
```

使用 Prisma 1，可以指定要在 `prisma.yml` 中使用的 Prisma 客户端的语言变体。对于 Prisma 2，该信息现在通过 `generator` 块在 Prisma 模型内指定。

> 注意：与 Prisma 1 不同，Prisma Client 2.0 的 TypeScript 和 JavaScript 变体使用名为 `prisma-client-js` 的*相同*生成器。即使在普通 JavaScript 项目中，`index.d.ts`中生成的类型也*总是*包含在内。即使不使用 TypeScript，也可以在 VS Code 中启用类似自动完成的功能。

## 3. 确定连接 URL 并连接到数据库

对于 Prisma 1，数据库连接在用于启动 Prisma 服务端的 Docker Compose 文件中配置。Prisma 服务端随后公开一个 GraphQL 接入点（通过 HTTP），该接入点代理来自 Prisma 客户端应用程序代码的所有数据库请求。该 HTTP 接入点是在 `prisma.yml` 中指定的。

使用 Prisma 2，HTTP 层不再公开，Prisma Client 2.0 配置为“直接”对数据库运行请求（即，请求由 Prisma 的 [请求引擎](../../../concepts/components/prisma-engines/query-engine)代理，但不再有额外的服务器）。

因此，作为下一步，您需要告诉 Prisma 2 使用的是哪种数据库（MySQL 或 PostgreSQL）以及它的*位置*。

首先，您需要确保 `schema.prisma` 内的 `datasource` 块上的 `provider` 字段配置为使用正确的数据库：

- 如果您使用的是 PostgreSQL，它需要在 `provider` 字段中定义值 `"postgresql"` 。
- 如果您使用的是 MySQL，它需要在 `provider` 字段中定义值 `"mysql"` 。

切换代码块中的选项卡以查看这两个示例：

<CodeBlock languages={["PostgreSQL", "MySQL"]}>

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

```prisma
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

</CodeBlock>

通过设置 `provider` 字段，您可以继续在 `.env` 文件中配置连接 URL。

假设 Docker Compose 文件中用于部署 Prisma 服务端的数据库配置如下所示：

<SwitchTech technologies={['*', 'postgresql']}>

```yml file=docker-compose.yml
PRISMA_CONFIG: |
  port: 4466
  databases:
    default:
      connector: postgres
      host: postgres
      port: 5432
      user: prisma
      password: prisma
```

还假设 `prisma.yml` 中的 `endpoint` 配置如下：

```yml file=prisma.yml
endpoint: http://localhost:4466/myproject/dev
```

根据这些连接详细信息，您需要在 `.env` 文件中配置 `DATABASE_URL` 环境变量，如下所示：

```bash file=.env
DATABASE_URL="postgresql://janedoe:randompassword@localhost:5432/prisma?schema=myproject$dev"
```

请注意，`schema` 参数通常由 _服务名称_ 和 _服务阶段_ 组成（它们是 `prisma.yml` 中 `endpoint` 的一部分），由 `$` 字符分隔。

有时在 `prisma.yml` 中没有指定服务名称和阶段：

```yml file=prisma.yml
endpoint: http://localhost:4466/
```

在这种情况下，必须按如下方式指定 `schema`：

```bash file=.env
DATABASE_URL="postgresql://janedoe:randompassword@localhost:5432/prisma?schema=default$default"
```

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```yml file=docker-compose.yml
PRISMA_CONFIG: |
  port: 4466
  databases:
    default:
      connector: mysql
      host: mysql
      port: 3306
      user: root
      password: randompassword
```

还假设 `prisma.yml` 中的 `endpoint` 配置如下：

```yml file=prisma.yml
endpoint: http://localhost:4466/myproject/dev
```

根据这些连接详细信息，您需要在 `.env` 文件中配置 `DATABASE_URL` 环境变量，如下所示：

```bash file=.env
DATABASE_URL="mysql://root:randompassword@localhost:3306/myproject@dev"
```

请注意，连接 URL 中的*数据库名称*通常由*服务名称*和*服务阶段*组成（它们是 `prisma.yml` 中 `endpoint` 的一部分），由 `@` 字符分隔。

有时在 `prisma.yml` 中没有指定服务名称和阶段：

```yml file=prisma.yml
endpoint: http://localhost:4466/
```

在这种情况下，必须按如下方式指定数据库名称：

```bash file=.env
DATABASE_URL="mysql://root:randompassword@localhost:3306/default@default"
```

</SwitchTech>

学习更多请前往[连接 URL](../../../reference/database-reference/connection-urls) 页面。

## 4. 内省数据库

在本指南中，我们将使用以下 Prisma 1 数据模型（选择如下 **SQL** 选项卡以查看数据模型在 SQL 中映射内容）：

<CodeBlock languages={["Prisma 1 datamodel", "SQL"]}>

```graphql
type User {
  id: ID! @id
  email: String @unique
  name: String!
  role: Role! @default(value: CUSTOMER)
  jsonData: Json
  profile: Profile
  posts: [Post!]!
}

type Post {
  id: ID! @id
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
  title: String!
  content: String
  published: Boolean! @default(value: false)
  author: User @relation(link: TABLE)
  categories: [Category!]!
}

type Profile {
  id: ID! @id
  bio: String
  user: User! @relation(link: INLINE)
}

type Category {
  id: ID! @id
  name: String!
  posts: [Post!]!
}

enum Role {
  ADMIN
  CUSTOMER
}
```

```sql
CREATE TABLE"User" (
    id character varying(25) PRIMARY KEY,
    email text,
    name text NOT NULL,
    role text NOT NULL,
    "jsonData" text
);
CREATE UNIQUE INDEX "User_pkey" ON"User"(id text_ops);
CREATE UNIQUE INDEX "default$default.User.email._UNIQUE" ON"User"(email text_ops);

CREATE TABLE"Post" (
    id character varying(25) PRIMARY KEY,
    title text NOT NULL,
    published boolean NOT NULL,
    "createdAt" timestamp(3) without time zone NOT NULL,
    "updatedAt" timestamp(3) without time zone NOT NULL,
    content text
);
CREATE UNIQUE INDEX "Post_pkey" ON"Post"(id text_ops);

CREATE TABLE"Profile" (
    id character varying(25) PRIMARY KEY,
    bio text,
    user character varying(25) REFERENCES"User"(id) ON DELETE SET NULL
);
CREATE UNIQUE INDEX "Profile_pkey" ON"Profile"(id text_ops);

CREATE TABLE"Category" (
    id character varying(25) PRIMARY KEY,
    name text NOT NULL
);
CREATE UNIQUE INDEX "Category_pkey" ON"Category"(id text_ops);

CREATE TABLE"_PostToUser" (
    "A" character varying(25) NOT NULL REFERENCES"Post"(id) ON DELETE CASCADE,
    "B" character varying(25) NOT NULL REFERENCES"User"(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX "_PostToUser_AB_unique" ON"_PostToUser"("A" text_ops,"B" text_ops);
CREATE INDEX "_PostToUser_B" ON"_PostToUser"("B" text_ops);

CREATE TABLE"_CategoryToPost" (
    "A" character varying(25) NOT NULL REFERENCES"Category"(id) ON DELETE CASCADE,
    "B" character varying(25) NOT NULL REFERENCES"Post"(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX "_CategoryToPost_AB_unique" ON"_CategoryToPost"("A" text_ops,"B" text_ops);
CREATE INDEX "_CategoryToPost_B" ON"_CategoryToPost"("B" text_ops);
```

</CodeBlock>

注意此数据模型有三种[关系](../../../../../../concepts/components/prisma-schema/relations)：

- 一对一： `User` ↔ `Profile`
- 一对多： `User` ↔ `Post` (由 `_PostToUser` 关系表维护)
- 多对多： `Post` ↔ `Category` (由 `_CategoryToPost` 关系表维护)

现在，您可以使用以下命令对数据库执行 Prisma 内省：

```terminal copy
npx prisma db pull
```

下面是调用 `db pull` 时发生的情况的图形化说明：

![使用 Prisma 内省你的数据库](https://res.cloudinary.com/prismaio/image/upload/v1628761155/docs/f7itiYw.png)

对于上述 Prisma 1 数据模型，这将导致以下 Prisma 2 模型（注意，模型已重新排序，以匹配 Prisma 1 数据模型的初始顺序）：

```prisma file=schema.prisma
model User {
  id       String    @id @default(cuid())
  email    String?   @unique
  name     String
  role     String
  jsonData String?
  Profile  Profile[]
  Post     Post[]
}

model Post {
  id        String     @id @default(cuid())
  createdAt DateTime
  updatedAt DateTime
  title     String
  content   String?
  published Boolean
  Category  Category[]
  User      User[]
}

model Profile {
  id   String  @id @default(cuid())
  bio  String?
  user String?
  User User?   @relation(fields: [user], references: [id])
}

model Category {
  id   String @id @default(cuid())
  name String
  Post Post[]
}
```

虽然这已经是一个有效的 Prisma 2 模型，但它缺少一部分 Prisma 1 时具有的等价*功能*：

- `Post` 上的 `createdAt` 和 `updatedAt` 字段没有自动生成的日期值`
- `User` 上的 `role` 字段没有默认值`
- `Post` 上的 `published` 字段没有默认值`

此外，还存在许多不一致之处，导致 Prisma Client API 不太惯用或符合人体工程学：

- `User` ↔ `Profile` 是一对多而还是一对一关系
- `User` ↔ `Post` 是多对多而还是一对多关系
- 关系字段是大写的（如：`User` 表上的 `Profile` 和 `Post`）
- `User` 表上的 `jsonData` 字段是 `String` 而不是 `Json` 类型
- `User` 上的 `role` 字段的类型为 `String` 而不是 `Role`，角色的 `enum` 定义完全缺失

虽然这些不一致实际上不会影响 Prisma Client API 中可用的 “功能集”，但它们会使您失去以前存在的某些约束或保证。

例如，Prisma 现在不会保证一个 `User` *至多*关联至一个 `Profile`，因为在内省期间表之间的关系被识别为一对多，因此一个 `User` 记录现在*可以*关联至多个 `Profile` 记录。

要了解更多有关不一致性的信息，请查阅 [模型不兼容](./schema-incompatibilities-postgres)页面。

在下面，我们将讨论这些不兼容性，并使用 Prisma 模型 Upgrade CLI 逐一修复它们。

## 5. 使用 Prisma Upgrade CLI 来解决模型不兼容问题

[Prisma Upgrade CLI](./how-to-upgrade#prisma-upgrade-cli)是一个交互式工具，可帮助您升级 Prisma 模型并消除上面列出的大部分不一致。

Prisma Upgrade CLI 用在两个主要阶段：

1. 通过纯 SQL 修复数据库模型
1. Prisma 2 模型所缺失的属性并修复其它问题

在第一阶段，它将生成并打印一些 SQL 语句，您应该对数据库运行这些 SQL 语句来调整数据库模型。在继续第二阶段之前，您可以运行所有语句或其中的一个子集。

在第二阶段，您不需要手动执行任何操作。 Upgrade CLI 将通过添加某些 Prisma 层属性（如 `@default(cuid))` 或 `@updatedAt`）对 Prisma 模型进行更改，调整关系字段的名称，使其与 Prisma 1 数据模型中的字段匹配，并确保 Prisma 1 数据模型两侧所需的 一对一 关系在 Prisma 2 模型中也是必需的。

请注意**您可以在流程的任何时间**重新开始，然后从第二阶段返回到第一阶段。

在本图中，绿色区域显示第一阶段，蓝色区域显示第二阶段。请注意，您可以选择在两个阶段之间运行 `prisma db pull` ，以更新您的 Prisma 数据模型：

![修复模型不兼容](https://res.cloudinary.com/prismaio/image/upload/v1628761153/docs/bsFu8HD.png)

要使用 Upgrade CLI，您可以在项目中本地安装它，也可以在不安装的情况下使用 `npx` 调用它一次，如下所示：

```terminal copy
npx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma
```

CLI 将向您发送以下消息：

```no-lines
◮ Welcome to the interactive Prisma Upgrade CLI that helps with the
upgrade process from Prisma 1 to Prisma 2.

Please read the docs to learn more about the upgrade process:
https://pris.ly/d/how-to-upgrade

➤ Goal
The Upgrade CLI helps you resolve the schema incompatibilities
between Prisma 1 and Prisma 2. Learn more in the docs:
https://pris.ly/d/schema-incompatibilities

➤ How it works
Throughout the process, you'll need to adjust your database schema by sending
SQL statements to it. The SQL statements are provided by the Upgrade CLI.

Note that the Upgrade CLI never makes changes to your database,
you are in full control over any operations that are executed against it.

You can stop and re-run the Upgrade CLI at any time.

These are the different steps of the upgrade process:

  1. The Upgrade CLI generates SQL commands for you to run on your database.
  2. You run the SQL commands against your database.
  3. You run the `npx prisma db pull` command again.
  4. You run the `npx prisma-upgrade` command again.
  5. The Upgrade CLI adjusts the Prisma 2 schema by adding missing attributes.

➤ Note
It is recommended that you make a full backup of your existing data before starting
the upgrade process. If possible, the migration should be performed in a staging
environment before executed against a production environment.

➤ Help
If you have any questions or run into any problems along the way,
please create an issue at:
https://github.com/prisma/upgrade/issues/new

Are you ready? [Y/n]
```

按下 <kbd>Y</kbd> 按钮， 然后敲下 <kbd>RETURN</kbd> 键继续。

确认后，CLI 将输出应针对数据库运行的 SQL 语句：

<SwitchTech technologies={['*', 'postgresql']}>

```no-lines
➤ Adjust your database schema
Run the following SQL statements against your database:

  Fix columns with ENUM data types
  https://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database

    CREATE TYPE "default$default"."Role" AS ENUM ('ADMIN', 'CUSTOMER');
    ALTER TABLE "default$default"."User" ALTER COLUMN "role" SET DATA TYPE "default$default"."Role" using "role"::"default$default"."Role";


  Add missing `DEFAULT` constraints to the database
  https://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database

    ALTER TABLE "default$default"."User" ALTER COLUMN "role" SET DEFAULT 'CUSTOMER';
    ALTER TABLE "default$default"."Post" ALTER COLUMN "published" SET DEFAULT false;


  Fix columns with JSON data types
  https://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database

    ALTER TABLE "default$default"."User" ALTER COLUMN "jsonData" SET DATA TYPE JSONB USING "jsonData"::TEXT::JSONB;


  Replicate `@createdAt` behavior in Prisma 2
  https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database

    ALTER TABLE "default$default"."Post" ALTER COLUMN "createdAt" SET DEFAULT CURRENT_TIMESTAMP;


  Fix 1-1 relations by adding `UNIQUE` constraints
  https://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint

    ALTER TABLE "default$default"."Profile" ADD UNIQUE ("user");


  Migrate IDs from varchar(25) to varchar(30)
  https://pris.ly/d/schema-incompatibilities#mismatching-cuid-length

    ALTER TABLE "default$default"."Category" ALTER COLUMN "id" SET DATA TYPE character varying(30);
    ALTER TABLE "default$default"."Post" ALTER COLUMN "id" SET DATA TYPE character varying(30);
    ALTER TABLE "default$default"."Profile" ALTER COLUMN "id" SET DATA TYPE character varying(30);
    ALTER TABLE "default$default"."Profile" ALTER COLUMN "user" SET DATA TYPE character varying(30);
    ALTER TABLE "default$default"."User" ALTER COLUMN "id" SET DATA TYPE character varying(30);

➤ Breaking changes detected

In order to fully optimize your database schema, you'll need to run a few SQL
statements that can break your Prisma 1 setup. Note that these changes are optional
and if you are upgrading gradually and running Prisma 1 and Prisma 2 side-by-side,
you should not perform these changes yet. Instead, you can perform them whenever
you are ready to completely remove Prisma 1 from your project.
If you are upgrading all at once, you can safely perform these changes now.

Learn more in the docs:
https://pris.ly/d/how-to-upgrade'
```

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
➤ Adjust your database schema
Run the following SQL statements against your database:

  Fix columns with ENUM data types
  https://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database

    ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL;


  Add missing `DEFAULT` constraints to the database
  https://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database

    ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL DEFAULT 'CUSTOMER';
    ALTER TABLE `Post` CHANGE `published` `published` TINYINT(1) NOT NULL DEFAULT 0;


  Fix columns with JSON data types
  https://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database

    ALTER TABLE `User` CHANGE `jsonData` `jsonData` JSON ;


  Replicate `@createdAt` behavior in Prisma 2.0
  https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database

    ALTER TABLE `Post` CHANGE `createdAt` `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;


  Fix 1-1 relations by adding `UNIQUE` constraints
  https://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint

    ALTER TABLE `Profile` ADD UNIQUE (`user`);


  Migrate IDs from varchar(25) to varchar(30)
  https://pris.ly/d/schema-incompatibilities#mismatching-cuid-length

    SET FOREIGN_KEY_CHECKS=0;
    ALTER TABLE `Category` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
    ALTER TABLE `Post` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
    ALTER TABLE `Profile` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
    ALTER TABLE `Profile` CHANGE `user` `user` char(30) CHARACTER SET utf8 ;
    ALTER TABLE `User` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
    SET FOREIGN_KEY_CHECKS=1;

➤ Breaking changes detected

In order to fully optimize your database schema, you'll need to run a few SQL
statements that can break your Prisma 1 setup. Note that these changes are optional
and if you are upgrading gradually and running Prisma 1 and Prisma 2 side-by-side,
you should not perform these changes yet. Instead, you can perform them whenever
you are ready to completely remove Prisma 1 from your project.
If you are upgrading all at once, you can safely perform these changes now.

Learn more in the docs:
https://pris.ly/d/how-to-upgrade'
```

</SwitchTech>

> 注意：如果您看到关于中断更改的注释，您可以暂时忽略它。我们以后再讨论。

所示的 SQL 语句被分类为许多 “bucket”，它们都旨在解决某种[模型不兼容](./schema-incompatibilities-postgres)：

- 修复具有 ENUM 数据类型的列
- 添加缺失的 `DEFAULT` 约束至数据库
- 修复具有 JSON 数据类型的列
- 复制 Prisma 2 `@createdAt` 表现
- 添加 `UNIQUE` 约束修复一对一关系

作为下一步，您可以开始向数据库发送 SQL 语句。请注意，所有这些更改都是非中断的，您可以继续同时使用 Prisma 1 与 Prisma 2。

下一节将分别介绍要发送至数据库的不同类型的 SQL 语句。

### 5.1. 通过纯 SQL 修复数据库模型（非中断）

在本节中，我们将浏览打印的 SQL 语句，并逐个在数据库中运行它们。

### 5.1.1. 修复具有 ENUM 数据类型的列

该工具所做的第一件事是帮助您确保 Prisma 1 数据模型中的 `enum` 定义在基础数据库中表示为实际的 `ENUM` 类型，现在它们表示为纯字符串（例如，在 MySQL 中表示为 `MEDIUMTEXT` ）。

CLI 当前显示以下输出：

<SwitchTech technologies={['*', 'postgres']}>

```no-lines
Fix columns with ENUM data types
https://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database

  CREATE TYPE "default$default"."Role" AS ENUM ('ADMIN', 'CUSTOMER');
  ALTER TABLE "default$default"."User" ALTER COLUMN "role" SET DATA TYPE "default$default"."Role" using "role"::"default$default"."Role";
```

> **⚠️ Warning**: If you are running Prisma 1 and Prisma 2 [side-by-side](./how-to-upgrade#upgrade-strategies), these [SQL statements will break your Prisma 1 setup](https://github.com/prisma/upgrade/issues/74). The docs will be updated to reflect this soon.

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
Fix columns with ENUM data types
https://pris.ly/d/schema-incompatibilities#enums-are-represented-as-text-in-database

  ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL;
```

</SwitchTech>

现在就开始对数据库运行这些语句。

![使用 SQL 将列更改为 ENUM](https://res.cloudinary.com/prismaio/image/upload/v1628761154/docs/Fo0LbzU.png)

### 5.1.2. 添加缺失的 `DEFAULT` 约束至数据库

接下来， Upgrade CLI 通过生成直接向数据库中添加相应 `DEFAULT` 约束的 SQL 语句，帮助您解决[数据库中未表示默认值](./schema-incompatibilities-postgres#default-values-arent-represented-in-database)的问题。

在这种情况下，缺少工具建议的两个 `DEFAULT` 约束：

<SwitchTech technologies={['*', 'postgres']}>

```no-lines
Add missing `DEFAULT` constraints to the database
https://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database

  ALTER TABLE "default$default"."User" ALTER COLUMN "role" SET DEFAULT 'CUSTOMER';
  ALTER TABLE "default$default"."Post" ALTER COLUMN "published" SET DEFAULT false;
```

现在，您可以使用命令行客户端或 Postco 之类的 GUI 对数据库执行以下 SQL 语句：

![添加缺失的 `DEFAULT` 约束至列](https://res.cloudinary.com/prismaio/image/upload/v1628761153/docs/o4dJJic.png)

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
Add missing `DEFAULT` constraints to the database
https://pris.ly/d/schema-incompatibilities#default-values-arent-represented-in-database

  ALTER TABLE `User` CHANGE `role` `role` ENUM('ADMIN', 'CUSTOMER') NOT NULL DEFAULT 'CUSTOMER';
  ALTER TABLE `Post` CHANGE `published` `published` TINYINT(1) NOT NULL DEFAULT 0;
```

现在，您可以使用命令行客户端或类似 TablePlus 的 GUI 对数据库运行以下 SQL 语句：

![TablePlus GUI](https://res.cloudinary.com/prismaio/image/upload/v1628761156/docs/Qr7L1Nc.png)

</SwitchTech>

### 5.1.3. 修复具有 JSON 数据类型的列

该工具所做的第一件事是帮助您确保 Prisma 1 数据模型中的 `enum` 定义在基础数据库中表示为实际的 `JSON` 类型，现在它们表示为纯字符串（例如，在 MySQL 中表示为 `MEDIUMTEXT` ）。

将列类型更改为 `JSON` 将确保在 Prisma 2 内省期间该字段被正确识别为 `Json`。

CLI 当前显示以下输出：

<SwitchTech technologies={['*', 'postgres']}>

```no-lines
Fix columns with JSON data types
https://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database

  ALTER TABLE "default$default"."User" ALTER COLUMN "jsonData" TYPE JSON  USING "jsonData"::json;
```

> **⚠️ 警告**: 如果你在[同时](./how-to-upgrade#upgrade-strategies)使用 Prisma 1 和 Prisma 2， 这些 [SQL 语句将打断 Prisma 1 配置](https://github.com/prisma/upgrade/issues/73)。文档将很快更新以说明此事。

现在，您可以使用命令行客户端或 Postco 之类的 GUI 对数据库执行以下 SQL 语句：

![添加缺失的 `DEFAULT` 约束至列](https://res.cloudinary.com/prismaio/image/upload/v1628761153/docs/o4dJJic.png)

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
Fix columns with JSON data types
https://pris.ly/d/schema-incompatibilities#json-type-is-represented-as-text-in-database

  ALTER TABLE `User` CHANGE `jsonData` `jsonData` JSON ;
```

现在，您可以使用命令行客户端或类似 TablePlus 的 GUI 对数据库运行以下 SQL 语句：

![TablePlus GUI](https://res.cloudinary.com/prismaio/image/upload/v1628761154/docs/feI3ZUF.png)

</SwitchTech>

### 5.1.4. 复制 Prisma 2 `@createdAt` 表现

这些工具所做的下一件事是帮助你解决 [`@createdAt` 不表现在数据库中](./schema-incompatibilities-postgres#default-values-arent-represented-in-database)问题

CLI 当前显示以下输出：

<SwitchTech technologies={['*', 'postgres']}>

```no-lines
Replicate `@createdAt` behavior in Prisma 2.0
https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database

  ALTER TABLE "default$default"."Post" ALTER COLUMN "createdAt" SET DEFAULT CURRENT_TIMESTAMP;
```

现在，您可以使用命令行客户端或 Postco 之类的 GUI 对数据库运行以下 SQL 语句：

![运行 SQL 命令以更改列](https://res.cloudinary.com/prismaio/image/upload/v1628761154/docs/PvuQVkj.png)

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
Replicate `@createdAt` behavior in Prisma 2.0
https://pris.ly/d/schema-incompatibilities#createdat-isnt-represented-in-database

  ALTER TABLE `Post` CHANGE `createdAt` `createdAt` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;
```

现在，您可以使用命令行客户端或类似 TablePlus 的 GUI 对数据库运行这些 SQL 语句。

</SwitchTech>

### 5.1.5. Fix 1-1 relations by adding `UNIQUE` constraints

Now, the tool will help you [turn the current 1-n relation between `User` ↔ `Profile` back into a 1-1 relation](./schema-incompatibilities-postgres#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint) by adding a `UNIQUE` constraint to the foreign key column called `user` (named after the relation field in the Prisma 1 datamodel) in the database.

The CLI currently shows the following output:

<SwitchTech technologies={['*', 'postgres']}>

```no-lines
Fix 1-1 relations by adding `UNIQUE` constraints
https://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint

  ALTER TABLE "default$default"."Profile" ADD UNIQUE ("user");
```

现在，您可以使用命令行客户端或 Postco 之类的 GUI 对数据库运行以下 SQL 语句：

![运行 SQL 命令以更改表](https://res.cloudinary.com/prismaio/image/upload/v1628761154/docs/PvuQVkj.png)

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
Fix 1-1 relations by adding `UNIQUE` constraints
https://pris.ly/d/schema-incompatibilities#inline-1-1-relations-are-recognized-as-1-n-missing-unique-constraint

  ALTER TABLE `Profile` ADD UNIQUE (`user`);
```

现在，您可以使用命令行客户端或类似 TablePlus 的 GUI 对数据库运行这些 SQL 语句。

</SwitchTech>

### 5.1.6. 修复 CUID 长度的不匹配问题

> 注意：即使更改了基础数据库中的列类型，这些 SQL 语句仍将继续出现在 Upgrade CLI 中。这是当前 Upgrade CLI 中的一个限制。

最后，该工具将通过向数据库中名为 `user`（根据 Prisma 1 数据模型中的关系字段命名）的外键列添加 `UNIQUE` 约束来帮助您[将当前为 `VARCHAR(25)` 类型的 ID 列转换为 `VARCHAR(30)` 类型](./schema-incompatibilities-postgres#mismatching-cuid-length)。

CLI 当前显示以下输出：

<SwitchTech technologies={['*', 'postgres']}>

```no-lines
Migrate IDs from varchar(25) to varchar(30)
https://pris.ly/d/schema-incompatibilities#mismatching-cuid-length

  ALTER TABLE "default$default"."Category" ALTER COLUMN "id" SET DATA TYPE character varying(30);
  ALTER TABLE "default$default"."Post" ALTER COLUMN "id" SET DATA TYPE character varying(30);
  ALTER TABLE "default$default"."Profile" ALTER COLUMN "id" SET DATA TYPE character varying(30);
  ALTER TABLE "default$default"."Profile" ALTER COLUMN "user" SET DATA TYPE character varying(30);
  ALTER TABLE "default$default"."User" ALTER COLUMN "id" SET DATA TYPE character varying(30);
```

现在，您可以使用命令行客户端或 Postco 之类的 GUI 对数据库运行以下 SQL 语句：

![运行 SQL 命令以更改表](https://res.cloudinary.com/prismaio/image/upload/v1628761154/docs/PvuQVkj.png)

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
Migrate IDs from varchar(25) to varchar(30)
https://pris.ly/d/schema-incompatibilities#mismatching-cuid-length

SET FOREIGN_KEY_CHECKS=0;
ALTER TABLE `Category` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
ALTER TABLE `Post` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
ALTER TABLE `Profile` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
ALTER TABLE `Profile` CHANGE `user` `user` char(30) CHARACTER SET utf8 ;
ALTER TABLE `User` CHANGE `id` `id` char(30) CHARACTER SET utf8 NOT NULL;
SET FOREIGN_KEY_CHECKS=1;
```

现在，您可以使用命令行客户端或 Postco 之类的 GUI 对数据库运行这些 SQL 语句。

</SwitchTech>

### 5.1.7. 检测破坏性更改

如果 Upgrade CLI 打印了关于中断更改的注释，则需要对数据库架构进行一些调整，以中断 Prisma 1 的兼容性，以便进行充分优化。

如果未检测到破坏性更改，您可以[跳到第 5.2 节](#52-re-introspect-your-database-to-update-your-prisma-schema)

根据您的[升级策略](./how-to-upgrade#upgrade-strategies)，您可以立即执行这些更改，也可以跳到 Upgrade CLI 的下一阶段：

- 如果您遵循渐进并行升级策略，请不要执行这些更改，因为它们将破坏您的 Prisma 1 设置。在这种情况下，您可以通过键入 <kbd>n</kbd> 并点击 <kbd>RETURN</kbd> 继续 Upgrade CLI 的下一阶段。
- 如果您遵循一次性升级策略，现在就可以执行这些更改。在这种情况下，继续键入 <kbd>Y</kbd> 并点击 <kbd>RETURN</kbd>。

### 5.2. 通过纯 SQL 修复数据库架构（破坏性）

在本节中，您将解决破坏 Prisma 1 设置的模式不兼容问题。如果项目中仍在运行 Prisma 1，请不要执行这些更改！

### 5.2.1. Fix incorrect m-n relations

现在，Upgrade CLI 帮助你修复 Prisma 1 内用关系表所表示的所有一对一和一对多关系[而在 Prisma 2 中仅作为多对多关系存在](./schema-incompatibilities-postgres#all-non-inline-relations-are-recognized-as-m-n)的问题。就本例来说，`User` ↔ `Post` 为多对多，但实际上*应该*是一对一关系。

要解决此问题，您需要执行以下迁移：

1. 在 `Post` 表上创建一个新的外键列，以直接链接到 `User` 表。
1. 将外键值从关系表迁移到 `Post` 表上的新外键列中。
1. 删除关系表。

以下说明由 CLI 打印：

<SwitchTech technologies={['*', 'postgres']}>

```no-lines
➤ Adjust your database schema
Run the following SQL statements against your database:

  Fix one-to-many table relations
  https://pris.ly/d/schema-incompatibilities#all-non-inline-relations-are-recognized-as-m-n

    ALTER TABLE "default$default"."Post" ADD COLUMN "authorId" character varying(25) ;
    ALTER TABLE "default$default"."Post" ADD CONSTRAINT "author" FOREIGN KEY ("authorId") REFERENCES "default$default"."User"("id");
    UPDATE "default$default"."Post" SET "authorId" = "default$default"."_PostToUser"."B" FROM "default$default"."_PostToUser" WHERE "default$default"."_PostToUser"."A" = "default$default"."Post"."id";
    DROP TABLE "default$default"."_PostToUser";


➤ Next Steps

After you executed one or more of the previous SQL statements against your database,
please run the following two commands to refresh your Prisma 2 schema and check
the changes.

  1. Run `npx prisma db pull` again to refresh your Prisma 2 schema.
  2. Run `npx prisma-upgrade` again.

If you can't or don't want to execute the remaining SQL statements right now, you can
skip to the last step where the Upgrade CLI adds missing attributes to your Prisma 2
schema that are not picked up by introspection.

Skip to the last step? [Y/n]?
```

对于此修复，您需要运行三条 SQL 语句：

1. 在 `Post` 表上创建新列 `authorId`。此列应为引用 `User` 表的 `id` 字段的*外键*：
   ```sql no-lines
   ALTER TABLE `Post` ADD COLUMN `authorId` VARCHAR(25);
   ALTER TABLE `Post` ADD FOREIGN KEY (`authorId`) REFERENCES `User` (`id`);
   ```
1. 编写一个 SQL 查询，读取 `_PostToUser` 关系表中的所有行，并对每行进行如下操作：
   1. 通过从 `A` 列中查找值来查找相应的 `Post` 记录
   1. 将列 `B` 中的值作为 `authorId` 的值插入到该 `Post` 记录中
   ```sql no-lines
   UPDATE Post, _PostToUser
   SET Post.authorId = _PostToUser.B
   WHERE Post.id = _PostToUser.A
   ```
1. 删除 `_PostToUser` 关系表
   ```sql no-lines
   DROP TABLE `_PostToUser`;
   ```

![通过 SQL 修复多对多关系](https://res.cloudinary.com/prismaio/image/upload/v1628761154/docs/nvrKuVJ.png)

</SwitchTech>

<SwitchTech technologies={['*', 'mysql']}>

```no-lines
➤ Adjust your database schema
Run the following SQL statements against your database:

  Fix one-to-many table relations
  https://pris.ly/d/schema-incompatibilities#all-non-inline-relations-are-recognized-as-m-n

    ALTER TABLE `Post` ADD COLUMN `authorId` char(25) CHARACTER SET utf8 ;
    ALTER TABLE `Post` ADD CONSTRAINT author FOREIGN KEY (`authorId`) REFERENCES `User`(`id`);
    UPDATE `Post`, `_PostToUser` SET `Post`.`authorId` = `_PostToUser`.B where `_PostToUser`.A = `Post`.`id`;
    DROP TABLE `_PostToUser`;


➤ Next Steps

After you executed one or more of the above SQL statements against your database,
please run the following two commands to refresh your Prisma 2 Schema and check
the changes.

  1. Run `npx prisma db pull` again to refresh your Prisma 2 schema.
  2. Run `npx prisma-upgrade` again.

If you can't or don't want to execute the remaining SQL statements right now, you can
skip to the last step where the Upgrade CLI adds missing attributes to your Prisma 2
schema that are not picked up by introspection.

Skip to the last step? [Y/n]?
```

For this fix, you'll need to run three SQL statements:

1. Create new column `authorId` on the `Post` table. This column should be a _foreign key_ that references the `id` field of the `User` table:
   ```sql no-lines
   ALTER TABLE `Post` ADD COLUMN `authorId` char(25) CHARACTER SET utf8 ;
   ALTER TABLE `Post` ADD CONSTRAINT author FOREIGN KEY (`authorId`) REFERENCES `User`(`id`);
   ```
1. Write a SQL query that reads all the rows from the `_PostToUser` relation table and for each row:
   1. Finds the respective `Post` record by looking up the value from column `A`
   1. Inserts the value from column `B` as the value for `authorId` into that `Post` record
   ```sql no-lines
   UPDATE `Post`, `_PostToUser` SET `Post`.`authorId` = `_PostToUser`.B where `_PostToUser`.A = `Post`.`id`;
   ```
1. Delete the `_PostToUser` relation table
   ```sql no-lines
   DROP TABLE `_PostToUser`;
   ```

![通过 SQL 修复多对多关系](https://res.cloudinary.com/prismaio/image/upload/v1628761154/docs/nvrKuVJ.png)

</SwitchTech>

执行这些命令后，关系表 `B` 列中记录的用户 ID 值将迁移到新的 `authorId` 列。

### 5.2. 重新内省数据库以更新 Prisma 模型

至此，您已经解决了与 Upgrade CLI 的模型不兼容问题。您现在可以通过键入 <kbd>n</kbd> 并点击 <kbd>RETURN</kbd> 退出 Upgrade CLI。

在本节中，您将使用开启另一轮自省更新 Prisma 模型。这一次，Prisma 模型以往的缺陷将得到解决，因为数据库模型已经调整：

```terminal copy
npx prisma db pull
```

这一次，生成的 Prisma 模型如下所示：

```prisma file=schema.prisma
model User {
  id       String   @id
  name     String
  email    String?  @unique
  jsonData Json?
  role     Role     @default(CUSTOMER)
  Post     Post[]
  Profile  Profile?
}

model Post {
  id        String     @id
  createdAt DateTime   @default(now())
  updatedAt DateTime
  title     String
  content   String?
  published Boolean    @default(false)
  authorId  String?
  User      User?      @relation(fields: [authorId], references: [id])
  Category  Category[] @relation(references: [id])
}

model Category {
  id   String @id
  name String
  Post Post[] @relation(references: [id])
}

model Profile {
  bio  String?
  id   String  @id
  user String? @unique
  User User?   @relation(fields: [user], references: [id])
}

enum Role {
  ADMIN
  CUSTOMER
}
```

此模式虽解决了大多数问题，但仍然缺少以下内容：

### 5.2. 将缺少的属性添加到 Prisma 2 模型并修复其他模型相关问题

CLI 现打印以下内容：

```no-lines
➤ What happens next
As a last step, some final adjustments will be made to your Prisma 2 schema
to carry over some Prisma-level attributes that aren't picked up by introspection.

As a last step, some final adjustments will be made to your Prisma 2.0
schema to carry over some Prisma-level attributes that aren't picked
up by introspection.

Warning
Your current Prisma 2.0 schema will be overwritten, so please
make sure you have a backup!

Are you ready? [Y/n]
```

此时，您要么运行 CLI 打印的所有 SQL 语句，要么跳过其中一些。无论哪种方式，现在都可以继续执行最后一步，让 Upgrade CLI 添加缺少的 Prisma 2 属性。通常如下所示：

- 添加 `@default(cuid())` 至 `@id` 字段
- 添加 `@updatedAt` 至所有在 Prisma 1 用过此属性的字段
- 用 `@map` 和 `@@map` 替代 Prisma 1 中的 `@db` 和 `@@db`

在该步骤中，Upgrade CLI 还修复了向 Prisma 2 过渡过程中出现的其他问题：

- 它确保 Prisma 1 中必需的一对一关系的双方在 Prisma 2 模型中也必需
- 它将关系字段重命名为 Prisma 1 数据模型中的相同名称（[即将推出](https://github.com/prisma/upgrade/issues/25))

要应用这些更改，可以重新运行 Upgrade CLI：

```terminal copy
npx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma
```

如果没有解决所有模型不兼容问题，Upgrade CLI 现在将打印其余的 SQL 语句（以及迁移 ID）。此时，您可以忽略它们，继续执行最后一步，方法是连续键入 <kbd>Y</kbd>，并在提示时单击 <kbd>RETURN</kbd>。

如果解决了所有模型不兼容问题，则不会打印 SQL 语句，Upgrade CLI 只输出以下内容：

```no-lines
$ npx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma

➤ Next Steps

After you executed one or more of the previous SQL statements against your database,
please run the following two commands to refresh your Prisma 2 schema and check
the changes.

  1. Run `npx prisma db pull` again to refresh your Prisma 2 schema.
  2. Run `npx prisma-upgrade` again.

If you can't or don't want to execute the remaining SQL statements right now, you can
skip to the last step where the Upgrade CLI adds missing attributes to your Prisma 2
schema that are not picked up by introspection.

Skip to the last step? [Y/n]?
```

再一次键入 <kbd>Y</kbd> 并敲击 <kbd>RETURN</kbd> 确认。

Upgrade CLI 的最后一个提示现在要求你确认它将对 Prisma 模型进行的上述更改：

```no-lines
➤ What happens next
As a last step, some final adjustments will be made to your Prisma 2 schema
to carry over some Prisma-level attributes that aren't picked up by introspection.

As a last step, some final adjustments will be made to your Prisma 2.0
schema to carry over some Prisma-level attributes that aren't picked
up by introspection.

Warning
Your current Prisma 2.0 schema will be overwritten, so please
make sure you have a backup!

Are you ready? [Y/n]
```

最后一次键入 <kbd>Y</kbd> 并敲击 <kbd>RETURN</kbd> 确认。

这是 Upgrade CLI 的最终输出：

```no-lines
Updating prisma/schema.prisma...
Done updating prisma/schema.prisma!

✔ Congratulations, you're all set!

➤ Note
If you didn't execute all generated SQL commands against your database,
you can re-run the Upgrade CLI at any time.

Note that the Upgrade CLI doesn't resolve all of the schema incompatibilities
between Prisma 1 and Prisma 2. If you want to resolve the remaining ones,
you can do so manually by following this guide:
https://pris.ly/d/upgrading-the-prisma-layer

➤ Next steps
Otherwise you can continue your upgrade process by installing Prisma Client 2:
npm install @prisma/client

You can find guides for different upgrade scenarios in the docs:
https://pris.ly/d/upgrade-from-prisma-1
```

### 5.3. 最终结果

Prisma 模型的最终版本应如下所示：

```prisma file=schema.prisma
model User {
  id       String   @id @default(cuid())
  name     String
  email    String?  @unique
  jsonData Json?
  role     Role     @default(CUSTOMER)
  Post     Post[]
  Profile  Profile?
}

model Post {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  title     String
  content   String?
  published Boolean    @default(false)
  authorId  String?
  User      User?      @relation(fields: [authorId], references: [id])
  Category  Category[] @relation(references: [id])
}

model Profile {
  id   String  @id @default(cuid())
  bio  String?
  user String? @unique
  User User?   @relation(fields: [user], references: [id])
}

model Category {
  id   String @id @default(cuid())
  name String
  Post Post[] @relation(references: [id])
}

enum Role {
  ADMIN
  CUSTOMER
}
```

### 5.4. 重命名关系字段

在这个版本的 Prisma 2 模型中，您会注意到，所有[关系字段](../../../../concepts/components/prisma-schema/relations#relation-fields)都是以各自的模型命名的，例如：

```prisma file=schema.prisma
model User {
  Post    Post[]
  Profile Profile?
}

model Post {
  User     User?      @relation(fields: [authorId], references: [id])
  Category Category[] @relation(references: [id])
}

model Profile {
  User User? @relation(fields: [user], references: [id])
}

model Category {
  Post Post[] @relation(references: [id])
}
```

这并不理想，事实上，您可以手动将它们全部重命名为以前的版本！

因为所有关系字段都是*虚拟的*，这意味着它们不在数据库中*显示*，所以您可以随意命名它们。在这种情况下，所有关系字段都是小写的，有时是复数的。

重命名后如下所示：

```prisma file=schema.prisma
model User {
  posts   Post[]
  profile Profile?
}

model Post {
  author     User?      @relation(fields: [authorId], references: [id])
  categories Category[] @relation(references: [id])
}

model Profile {
  user  String? @unique
  owner User?   @relation(fields: [user], references: [id])
}

model Category {
  posts Post[] @relation(references: [id])
}
```

> 注意：对于 `User` 和 `Profile` 之间的一对一关系，无法为关系字段设置旧名称 `user`。这是因为与保存外键的现有[关系常量](../../../../../../concepts/components/prisma-schema/relations#annotated-relation-fields-and-relation-scalar-fields)字段存在命名冲突。在这种情况下，您可以选择其他名称，或者直接通过 SQL 在数据库中重命名外键列。

### 5.5. 解决剩余的模型不兼容问题

Upgrade CLI 尚未解决一些架构不兼容问题。在这一点上，您还没有修复[标量列表](./schema-incompatibilities-postgres#scalar-lists-arrays-are-maintained-with-extra-table)和[级联删除](./schema-incompatibilities-postgres#cascading-deletes-are-not-supported-in-prisma-2)。您可以在[模型不兼容](./schema-incompatibilities-postgres)找到这些建议的解决方案。

## 6. 安装并生成 Prisma Client

现在您已经准备好 Prisma 2 模型，可以使用以下命令安装 Prisma Client：

```terminal copy
npm install @prisma/client
```

## 7. 下一步

恭喜，您现在已将 Prisma 层 升级到 Prisma 2！从这里开始，您可以使用以下指南之一继续更新应用程序代码：

- [由旧版更新至新版 Nexus](./upgrading-nexus-prisma-to-nexus)：如果您当前正在使用 GraphQL Nexus 运行 Prisma 1，请选择本指南。
- [由 prisma-binding 更新至 Nexus](./upgrading-prisma-binding-to-nexus)：如果您当前正在运行带 `prisma-binding` 的 Prisma 1，并希望升级到[Nexus](https://www.nexusjs.org/#/)（可使用 TypeScript），请选择本指南。
- [由 prisma-binding 更新至 SDL-first](./upgrading-prisma-binding-to-sdl-first)：如果您当前正在运行带 `prisma-binding` 的 Prisma 1，并且希望升级到 [SDL-first](https://www.prisma.io/blog/the-problems-of-schema-first-graphql-development-x1mn4cb0tyl3/) GraphQL 服务器，请选择本指南。
- [REST API](./upgrading-a-rest-api)：如果您当前正在使用 Prisma client 1 运行 Prisma 1，并且正在构建 REST API，请选择本指南。

## Bonus: Prisma Client API 比较

本节包含 Prisma 1 和 Prisma 2 的 Prisma Client API 的高级并行比较。有关新 Prisma 客户端 API 的更多详细信息，您可以浏览 [Prisma Client](../../../concepts/components/prisma-client) 文档。

### 读取单一记录

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
const user = await prisma.user({ id: 1 })
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.findUnique({
  where: { id: 1 },
})
```

</block>

</ParallelBlocks>

### 读取记录列表

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
const user = await prisma.users()
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.findMany()
```

</block>

</ParallelBlocks>

### 列表筛选

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
const users = await prisma.users({
  where: {
    name: 'Alice',
  },
})
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.findMany({
  where: {
    name: 'Alice',
  },
})
```

</block>

</ParallelBlocks>

### 列表分页

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
const posts = await prisma.posts({
  skip: 5,
  first: 10,
})
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.findMany({
  skip: 5,
  take: 10,
})
```

</block>

</ParallelBlocks>

> 注意：您可以在相应的[发行说明](https://github.com/prisma/prisma/releases/tag/2.0.0-beta.7)中了解有关新分页 API 的更多信息或文档中的[分页](../../../concepts/components/prisma-client/pagination)页面。

### 列表排序

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
await prisma.posts({
  orderBy: 'title_ASC',
})
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.posts({
  orderBy: {
    title: 'asc',
  },
})
```

</block>

</ParallelBlocks>

### 创建记录

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
await prisma.createUser({
  name: 'Alice',
})
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.create({
  data: {
    name: 'Alice',
  },
})
```

</block>

</ParallelBlocks>

### 更新记录

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
await prisma.updateUser({
  where: { id: 1 },
  data: {
    name: 'James',
    email: 'james@prisma.io',
  },
})
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.update({
  where: { id: 1 },
  data: {
    name: 'James',
    email: 'james@prisma.io',
  },
})
```

</block>

</ParallelBlocks>

### 删除记录

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
await prisma.deleteUser({ id: 1 })
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.delete({
  where: { id: 1 },
})
```

</block>

</ParallelBlocks>

### 选择字段与加载关系

在 Prisma 1 中，选择对象的特定字段与加载关系的唯一方法是使用基于字符串的 `$fragment` 和 `$graphql` 函数。对于 Prisma 2，现在可以使用 [`select`](../../../concepts/components/prisma-client/select-fields#select-specific-fields) 和 [`include`](../../../concepts/components/prisma-client/select-fields#include-relations-and-select-relation-fields) 以干净和类型安全的方式完成此操作。

这种方法的另一个好处是，你可以在*任何* Prisma Client 查询上使用 `select` 和 `include`，例如：`findUnique`, `findMany`, `create`, `update`, `delete`, ...

<ParallelBlocks>

<block content={<FileWithIcon text="Prisma client (v1)" icon="code"/>}>

```ts
await prisma.user({ id: 1 }).$fragment(`
  fragment NameAndEmail on User { id email }`
`)
```

</block>

<block content={<FileWithIcon text="Prisma Client (v2)" icon="code"/>}>

```ts
await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    id: true,
    email: true,
  },
})
```

</block>

</ParallelBlocks>

例如，在 Prisma 1 中不可能创建新记录并仅检索返回对象中的 `id`。使用 Prisma 2，您可以通过以下方式实现：

```ts
await prisma.user.create({
  data: {
    name: 'Alice',
  },
  select: {
    id: true,
  },
})
```
